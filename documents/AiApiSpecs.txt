
function call 
FROM lib.rs TO lib.rs

### PUT into API call ###
softwarename: string,
optionally URL: string,

### API call returns ###

- Vendor reputation
- CVE history + trends
- Incidents / abuse signals
- Data handling + compliance
- Deployment + admin controls
- 0–100 trust/risk score with rationale
- Confidence rating
- Suggest 1–2 safer alternatives with short rationales.

### make sure AI prioritizes sources like: ###

- PSRIT
- Terms of service/data processing agreement
- Systems and organization controls type II
- ISO attestations
- Reputable advisories/CERTS
- CISA known exploited vulnerabilities catalog

AI Prompt Code:

use async_openai::{
    config::Config,
    types::{
        ChatCompletionRequestMessage, ChatCompletionRequestSystemMessageArgs,
        ChatCompletionRequestUserMessageArgs, CreateChatCompletionRequestArgs,
    },
    Client,
};
use serde::{Deserialize, Serialize};

// Response struct that matches what OpenAI returns
#[derive(Debug, Serialize, Deserialize)]
pub struct SoftwareAnalysis {
    pub name: String,
    pub clearance: bool,
    pub description: String,
    pub vendor_reputation: String,
    pub cve_history: String,
    pub incidents: String,
    pub datahandling_and_compliance: String,
    pub trust_score: i32,
    pub confidence_rating: i32,
    pub alternative: String,
}

impl SoftwareAnalysis {
    pub fn dummy(name: String) -> Self {
        SoftwareAnalysis {
            name: name.clone(),
            clearance: true,
            description: format!("This is a dummy analysis for {}", name),
            vendor_reputation: "No data available - dummy response".to_string(),
            cve_history: "No CVEs found - dummy response".to_string(),
            incidents: "No incidents reported - dummy response".to_string(),
            datahandling_and_compliance: "Unknown - dummy response".to_string(),
            trust_score: 50,
            confidence_rating: 0,
            alternative: "N/A - dummy response".to_string(),
        }
    }
}

pub struct OpenAIRequest {
    pub sw_name: String,
    pub sw_url: Option<String>,
    pub priority_sources: Vec<String>,
}

impl OpenAIRequest {
    pub fn new(sw_name: String) -> Self {
        OpenAIRequest {
            sw_name,
            sw_url: None,
            priority_sources: vec![],
        }
    }

    pub fn with_url(mut self, url: String) -> Self {
        self.sw_url = Some(url);
        self
    }
}

// The real implementation
pub async fn fetch_software_info(
    request: &OpenAIRequest,
    api_key: &str,
) -> Result<SoftwareAnalysis, String> {
    // Configure OpenAI client
    let config = Config::new().with_api_key(api_key.to_string());
    let client = Client::with_config(config);

    // System prompt: your CISO/security-assessor role
    let system_prompt = r#"
You are an expert security analyst and CISO advisor specializing in rapid software security assessments.
Your role is to evaluate software products and provide actionable, source-grounded security intelligence.

Core Responsibilities:
1. Gather information from TRUSTED sources only
2. Distinguish between vendor-stated claims and independent verification
3. Provide accurate CVE analysis with trend assessment
4. Evaluate compliance posture and data handling practices
5. Generate defensible trust scores with clear rationale
6. Suggest safer alternatives when appropriate

Source Prioritization (in order):
- PSIRT / Vendor Security Page
- CISA KEV (Known Exploited Vulnerabilities catalog)
- CERT/CSIRT advisories (e.g., US-CERT, NCSC, vendor CERTs)
- NVD/MITRE CVE databases with CVSS scores
- SOC 2 Type II reports and ISO 27001+ certifications
- Terms of Service, DPA, Privacy Policy, security whitepapers
- Public breach notifications and incident disclosures

Analysis principles:
- Evidence-based only
- If evidence is missing, say so explicitly in the relevant fields
- Prefer information from the last 12–24 months for trends

You MUST output ONLY a single JSON object with this exact structure (no markdown, no extra text):

{
  "name": string,
  "clearance": boolean,
  "description": string,
  "vendor_reputation": string,
  "cve_history": string,
  "incidents": string,
  "datahandling_and_compliance": string,
  "trust_score": integer (0-100),
  "confidence_rating": integer (0-100),
  "alternative": string
}

Do not include comments. Do not wrap in backticks. JSON only.
"#;

    // User prompt: software name + optional URL
    let user_prompt = format!(
        "Assess the security posture of the following software:\n\nName: {}\nURL: {}\n\nIf URL is 'None', infer the vendor and product from the name alone.",
        request.sw_name,
        request.sw_url.clone().unwrap_or_else(|| "None".to_string())
    );

    // Build messages
    let system_message: ChatCompletionRequestMessage =
        ChatCompletionRequestSystemMessageArgs::default()
            .content(system_prompt)
            .build()
            .map_err(|e| e.to_string())?
            .into();

    let user_message: ChatCompletionRequestMessage =
        ChatCompletionRequestUserMessageArgs::default()
            .content(user_prompt)
            .build()
            .map_err(|e| e.to_string())?
            .into();

    // Build chat completion request
    let chat_request = CreateChatCompletionRequestArgs::default()
        .model("gpt-4.1-mini") // or "gpt-4.1"
        .messages(vec![system_message, user_message])
        .temperature(0.0)
        .build()
        .map_err(|e| e.to_string())?;

    // Call OpenAI
    let response = client
        .chat()
        .create(chat_request)
        .await
        .map_err(|e| e.to_string())?;

    // Extract content (the JSON string)
    let content = response
        .choices
        .get(0)
        .and_then(|c| c.message.content.clone())
        .ok_or_else(|| "No content returned from OpenAI".to_string())?;

    // Parse JSON into SoftwareAnalysis
    let analysis: SoftwareAnalysis =
        serde_json::from_str(&content).map_err(|e| format!("JSON parse error: {e}\nRaw: {content}"))?;

    Ok(analysis)
}
