
function call 
FROM lib.rs TO lib.rs

### PUT into API call ###
softwarename: string,
optionally URL: string,

### API call returns ###

- Vendor reputation
- CVE history + trends
- Incidents / abuse signals
- Data handling + compliance
- Deployment + admin controls
- 0–100 trust/risk score with rationale
- Confidence rating
- Suggest 1–2 safer alternatives with short rationales.

### make sure AI prioritizes sources like: ###

- PSRIT
- Terms of service/data processing agreement
- Systems and organization controls type II
- ISO attestations
- Reputable advisories/CERTS
- CISA known exploited vulnerabilities catalog

AI Prompt Code:

Cargoon

Lisää [dependencies]:

reqwest = { version = "0.11", features = ["json", "rustls-tls"] }

Manageriin:
use reqwest::Client;
use serde::{Deserialize, Serialize};
use serde_json::json;

/// Response struct your app uses internally
#[derive(Debug, Serialize, Deserialize)]
pub struct SoftwareAnalysis {
    pub name: String,
    pub clearance: bool,
    pub description: String,
    pub vendor_reputation: String,
    pub cve_history: String,
    pub incidents: String,
    pub datahandling_and_compliance: String,
    pub trust_score: i32,
    pub confidence_rating: i32,
    pub alternative: String,
}

impl SoftwareAnalysis {
    pub fn dummy(name: String) -> Self {
        SoftwareAnalysis {
            name: name.clone(),
            clearance: true,
            description: format!("This is a dummy analysis for {}", name),
            vendor_reputation: "No data available - dummy response".to_string(),
            cve_history: "No CVEs found - dummy response".to_string(),
            incidents: "No incidents reported - dummy response".to_string(),
            datahandling_and_compliance: "Unknown - dummy response".to_string(),
            trust_score: 50,
            confidence_rating: 0,
            alternative: "N/A - dummy response".to_string(),
        }
    }
}

/// Request struct used by lib.rs
pub struct OpenAIRequest {
    pub sw_name: String,
    pub sw_url: Option<String>,
    pub priority_sources: Vec<String>,
}

impl OpenAIRequest {
    pub fn new(sw_name: String) -> Self {
        OpenAIRequest {
            sw_name,
            sw_url: None,
            priority_sources: vec![],
        }
    }

    pub fn with_url(mut self, url: String) -> Self {
        self.sw_url = Some(url);
        self
    }
}

/// Call OpenAI Responses API with web_search and map the result into SoftwareAnalysis.
///
/// From lib.rs you already call:
///   let response = open_ai_manager::fetch_software_info(&request, &key).await?;
///
/// This keeps that API but internally the LLM output is a single semicolon-separated line.
pub async fn fetch_software_info(
    request: &OpenAIRequest,
    api_key: &str,
) -> Result<SoftwareAnalysis, String> {
    let client = Client::new();

    // System instructions: what the model should do and how to format output
    let system_instructions = r#"
You are an expert security analyst and CISO advisor specializing in rapid software security assessments.

Use live, up-to-date information via web search to assess the security posture of the given software.

Prioritize these sources in your reasoning:
- PSIRT / vendor security or trust pages
- Terms of Service, Data Processing Agreements, Privacy Policies
- SOC 2 Type II and ISO 27001/27017/27018/27701 certifications
- CERT / CSIRT advisories
- CISA Known Exploited Vulnerabilities catalog
- CVE databases (NVD / MITRE) and CVSS scores

Analysis rules:
- Be evidence-based; do NOT invent facts.
- When you cannot find reliable evidence for a topic, use the phrase: “Insufficient public evidence”.
- Distinguish between vendor-stated claims and independent sources in wording when relevant.
- Focus on the last 12–24 months for CVE/incident trends where possible.

Output format:
Return EXACTLY ONE LINE, with fields in this order, separated by semicolons:

description; vendor_reputation; cve_history; incidents; datahandling_and_compliance; trust_score_0_to_100; confidence_0_to_100; safer_alternatives;

Rules:
- No line breaks inside fields.
- No extra text before or after the line.
- No JSON, no markdown.
"#;

    // Build user input from your current request type
    let user_input = format!(
        "software_name: {}\nsoftware_url: {}\n\nGenerate the semicolon-separated assessment line as specified.",
        request.sw_name,
        request.sw_url.clone().unwrap_or_else(|| "Unknown".to_string())
    );

    // Build the Responses API payload with web_search enabled
    let body = json!({
        "model": "gpt-4.1",
        "tools": [
            { "type": "web_search_preview" }
        ],
        "input": [
            {
                "role": "system",
                "content": system_instructions
            },
            {
                "role": "user",
                "content": user_input
            }
        ]
    });

    // Call /v1/responses
    let res = client
        .post("https://api.openai.com/v1/responses")
        .bearer_auth(api_key)
        .json(&body)
        .send()
        .await
        .map_err(|e| format!("HTTP error: {e}"))?
        .error_for_status()
        .map_err(|e| format!("API status error: {e}"))?;

    let json: serde_json::Value = res
        .json()
        .await
        .map_err(|e| format!("JSON decode error: {e}"))?;

    // Extract the assistant's text from the Responses API format:
    // response.output is an array; find the "message" item and then its "output_text"
    let output_items = json["output"]
        .as_array()
        .ok_or_else(|| "Missing 'output' array in Responses result".to_string())?;

    let mut line: Option<String> = None;

    for item in output_items {
        if item["type"] == "message" {
            if let Some(content_arr) = item["content"].as_array() {
                for c in content_arr {
                    if c["type"] == "output_text" {
                        if let Some(text) = c["text"].as_str() {
                            line = Some(text.trim().to_string());
                            break;
                        }
                    }
                }
            }
        }
        if line.is_some() {
            break;
        }
    }

    let line = match line {
        Some(l) => l,
        None => {
            // Fall back to dummy if no usable output
            return Ok(SoftwareAnalysis::dummy(request.sw_name.clone()));
        }
    };

    // Now parse the semicolon-separated line into fields
    let parts: Vec<String> = line
        .split(';')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();

    // We expect 8 fields based on the system_instructions
    if parts.len() < 8 {
        // If parsing fails, fall back to dummy
        return Ok(SoftwareAnalysis::dummy(request.sw_name.clone()));
    }

    let description = parts[0].clone();
    let vendor_reputation = parts[1].clone();
    let cve_history = parts[2].clone();
    let incidents = parts[3].clone();
    let datahandling_and_compliance = parts[4].clone();

    // Try to parse trust_score and confidence; default if parsing fails
    let trust_score: i32 = parts[5]
        .split_whitespace()
        .next()
        .and_then(|num| num.parse::<i32>().ok())
        .unwrap_or(50);

    let confidence_rating: i32 = parts[6]
        .split_whitespace()
        .next()
        .and_then(|num| num.parse::<i32>().ok())
        .unwrap_or(50);

    let alternative = parts[7].clone();

    // Simple clearance heuristic: trust_score >= 70 => true, else false
    let clearance = trust_score >= 70;

    let analysis = SoftwareAnalysis {
        name: request.sw_name.clone(),
        clearance,
        description,
        vendor_reputation,
        cve_history,
        incidents,
        datahandling_and_compliance,
        trust_score,
        confidence_rating,
        alternative,
    };

    Ok(analysis)
}
